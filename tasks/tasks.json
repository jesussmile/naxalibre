{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Research and Document LERC Bindings Generation Process",
        "description": "Investigate and thoroughly document the process for generating LERC bindings from the flightcanvas_terrain/lerc-master repository, with a focus on porting the process to the Naxalibre project. This includes understanding the LERC library source, the C++ wrapper, FFI binding generation with ffigen, and platform-specific build steps for Android and iOS. The documentation should detail how to adapt and integrate these components into the Naxalibre project structure.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "1. Review the flightcanvas_terrain/lerc-master repository to understand its use of LERC version 4.0.0 from Esri, included under /lerc-master/ as a C++ library for raster compression.\n2. Analyze the C wrapper (src/lerc_wrapper.h and src/lerc_wrapper.cpp) that exposes simplified C functions for Dart FFI, including initialization, decoding, memory management, and the LercInfo struct for metadata.\n3. Document the process of generating Dart FFI bindings using the ffigen package, including:\n   - Creating a ffigen.yaml configuration that specifies the output file (e.g., lib/src/bindings/lerc_bindings.dart), header entry point (src/lerc_wrapper.h), and necessary compiler options for both Android and iOS[1][2][4].\n   - Running ffigen via the Dart CLI to generate bindings, and integrating the generated Dart code into the project[1][2][3][4].\n4. Detail the platform-specific build processes:\n   - For Android: Using CMake (CMakeLists.txt) to build both the static lerc library and the shared lerc_wrapper library, outputting to android/app/src/main/jniLibs/${ANDROID_ABI}.\n   - For iOS: Using shell scripts (setup_lerc_ios.sh, compile_lerc_ios.sh) to create a framework, outputting to ios/Frameworks, and handling iOS-specific settings like bitcode embedding.\n   - Coordinating builds for both platforms using a main build_native.sh script, handling multiple Android ABIs and iOS arm64 architecture.\n5. Provide step-by-step guidance for porting this process to Naxalibre:\n   - Copying the LERC library and wrapper code\n   - Adapting build scripts for the Naxalibre project structure\n   - Configuring ffigen for the new project\n   - Updating platform-specific configurations\n   - Ensuring integration with Naxalibre's existing build system\n6. Include code snippets, configuration examples, and references to relevant documentation. Highlight potential pitfalls and best practices for maintaining the bindings across platforms.",
        "testStrategy": "1. Review the produced documentation for completeness, ensuring it covers: (a) the LERC library structure and wrapper, (b) ffigen configuration and usage, (c) Android and iOS build steps, (d) porting steps to Naxalibre, and (e) troubleshooting tips. 2. Validate that a developer unfamiliar with the process can follow the documentation to generate FFI bindings and build the native library for both Android and iOS within the Naxalibre project. 3. Cross-check referenced commands, configuration files, and build outputs for accuracy. 4. Solicit peer review from at least one other developer to confirm clarity and completeness.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Establish Initial Directory Structure for Terrain Visualization Integration",
        "description": "Set up the foundational directory structure for integrating terrain visualization in the Naxalibre project, including dedicated folders for LERC native code, CMake configuration, and essential build scripts.",
        "details": "Create a top-level 'terrain' or 'terrain-visualization' directory within the Naxalibre project. Inside this, establish subdirectories for 'lerc-native' (to house LERC codec source and headers), 'cmake' (for CMake modules and configuration files), and 'scripts' (for build and utility scripts). Initialize placeholder README files in each directory to document their purpose. Prepare a root-level CMakeLists.txt that includes the LERC native code as a subdirectory and configures build targets appropriately. Ensure the structure is compatible with cross-platform builds and future integration with the main Naxalibre build system. Document the directory layout and provide guidance for adding new native modules or scripts.",
        "testStrategy": "Verify that the directory structure matches the documented layout. Confirm that all expected subdirectories and placeholder files exist. Run CMake configuration from the project root to ensure it recognizes the new directories and generates build files without errors. Check that the build scripts are executable and reference the correct paths. Review documentation for clarity and completeness.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement TerrainLoaderScreen with Terrain Visualization Controls",
        "description": "Develop a TerrainLoaderScreen class in the Naxalibre example app, modeled after MBTilesLoaderScreen, featuring UI controls for terrain visualization such as opacity, tile size, and layer toggling.",
        "details": "Begin by reviewing the existing MBTilesLoaderScreen implementation to ensure consistency in UI/UX and code structure. Create a new TerrainLoaderScreen class within the appropriate module of the Naxalibre example app. Implement UI controls for adjusting terrain opacity (e.g., using a slider), selecting tile size (dropdown or segmented control), and toggling terrain layers (checkboxes or switches). Integrate these controls with the terrain rendering logic so that user input dynamically updates the visualization. Ensure the screen handles loading, error states, and provides feedback to the user. Follow established patterns for state management and component reuse. Document the new class and its public interface for future maintainability.",
        "testStrategy": "1. Launch the Naxalibre example app and navigate to the TerrainLoaderScreen. 2. Verify that all UI controls (opacity slider, tile size selector, layer toggles) are present and functional. 3. Adjust opacity and confirm that terrain transparency updates in real time. 4. Change tile size and ensure the terrain tiles re-render accordingly. 5. Toggle terrain layers on and off, verifying that the visualization updates as expected. 6. Test error handling by simulating failed terrain loads. 7. Review code for adherence to style and documentation standards.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Port LERC Decoder from FlightCanvas Terrain to Naxalibre",
        "description": "Port the LERC decoder functionality from FlightCanvas Terrain to Naxalibre, implementing Dart classes for loading and decoding LERC terrain data.",
        "details": "Analyze the existing LERC decoder implementation in FlightCanvas Terrain, focusing on how it loads and decodes LERC-compressed terrain data. Re-implement the decoder logic in Dart, ensuring compatibility with the Naxalibre architecture. Create Dart classes that handle reading LERC byte blobs, extracting header information, and decoding pixel data into usable terrain elevation arrays. Reference the official LERC C API documentation for decoding logic, including functions like lerc_getBlobInfo and lerc_decode, and adapt these to Dart idioms. Ensure the implementation supports various pixel types and multi-band data as per the LERC specification. Document the API and usage patterns for integration with Naxalibre's terrain pipeline.",
        "testStrategy": "1. Prepare a suite of LERC-encoded terrain files with known properties and values. 2. Write unit tests to verify that the Dart decoder correctly loads and decodes these files, matching expected elevation arrays. 3. Test edge cases such as multi-band data, different pixel types, and corrupted files. 4. Integrate the decoder into a sample Naxalibre workflow and visually verify terrain rendering. 5. Compare decoded output against reference implementations (e.g., Esri's C/C++ or JavaScript decoders) for accuracy.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Terrain and Hillshade Layer Rendering in Naxalibre",
        "description": "Port and adapt terrain and hillshade rendering classes from FlightCanvas Terrain to Naxalibre, integrating them with the existing map implementation.",
        "details": "Begin by analyzing the relevant terrain and hillshade rendering classes in FlightCanvas Terrain, focusing on their data structures, rendering logic, and dependencies. Refactor these classes to decouple them from FlightCanvas-specific APIs and adapt them to the architecture and data flow of Naxalibre, ensuring compatibility with MapLibre's map and layer management. Integrate the adapted classes as new layers within Naxalibre, leveraging MapLibre's style and source mechanisms for terrain and hillshade data. Pay special attention to coordinate transformations, tile management, and shader compatibility. Update the Naxalibre map initialization and style configuration to support dynamic addition and removal of terrain and hillshade layers. Document the integration points and any new configuration options required for users to enable these layers.",
        "testStrategy": "1. Add sample terrain and hillshade data sources to a Naxalibre map instance and verify that the layers render correctly at various zoom levels and map positions. 2. Compare rendered output against reference images from FlightCanvas to ensure visual fidelity. 3. Test dynamic addition and removal of terrain and hillshade layers at runtime. 4. Validate performance and responsiveness, especially during map interactions such as pan and zoom. 5. Review code for adherence to Naxalibre and MapLibre architectural patterns and ensure no residual dependencies on FlightCanvas remain.",
        "status": "pending",
        "dependencies": [
          1,
          3,
          "4"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Altitude Wheel Slider Control for Terrain Visualization",
        "description": "Adapt and implement the custom altitude wheel slider from FlightCanvas Terrain into the Naxalibre example app for interactive terrain altitude selection.",
        "details": "Begin by reviewing the existing wheel slider control implementation in FlightCanvas Terrain, focusing on its UI logic, event handling, and data binding. Refactor the component as needed to decouple it from FlightCanvas-specific dependencies, ensuring compatibility with the Naxalibre app's architecture and state management. Integrate the adapted slider into the terrain visualization screen, wiring up its value changes to update the displayed terrain altitude in real time. Ensure the control is accessible, visually consistent with the app's design system, and supports both mouse and touch input. Document any new props, events, or integration points for future maintainability.",
        "testStrategy": "1. Verify the wheel slider renders correctly within the Naxalibre app and matches design specifications. 2. Interact with the slider using mouse and touch to confirm smooth, accurate altitude selection. 3. Ensure that adjusting the slider updates the terrain visualization altitude in real time. 4. Test edge cases such as minimum and maximum altitude values. 5. Confirm accessibility features (keyboard navigation, ARIA labels) are present. 6. Review code for modularity and adherence to app architecture. 7. Run regression tests to ensure no impact on unrelated features.",
        "status": "pending",
        "dependencies": [
          3,
          "5"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Terrain Caching System in Naxalibre Based on FlightCanvas Terrain",
        "description": "Develop a terrain caching system in Naxalibre to optimize performance, using the caching strategies from FlightCanvas Terrain as a reference.",
        "details": "Analyze the caching implementation in FlightCanvas Terrain, focusing on how terrain data (including textures, meshes, and objects) is stored, retrieved, and invalidated. Design a modular caching layer in Naxalibre that preloads and retains off-screen terrain data at configurable quality levels, similar to the 'offscreen terrain pre-caching' settings found in modern simulators. Implement mechanisms to manage memory usage, cache eviction policies (e.g., LRU), and dynamic adjustment of cache detail based on user settings or system resources. Ensure the system supports seamless transitions when the camera moves, minimizing stutters and loading delays. Provide configuration options for cache size and quality, and document integration points for terrain streaming subsystems. Consider thread safety and performance impacts during implementation.",
        "testStrategy": "1. Simulate camera movement across large terrain areas and verify that previously visited terrain is loaded from cache without noticeable stutter or delay. 2. Adjust cache size and quality settings, confirming that memory usage and performance respond accordingly. 3. Stress-test with rapid camera rotations and movement to ensure the cache handles high churn without crashes or excessive memory growth. 4. Compare performance metrics (frame time, memory usage) before and after caching implementation. 5. Validate that cache eviction and invalidation policies work as intended by monitoring cache hits/misses and ensuring old data is purged appropriately.",
        "status": "pending",
        "dependencies": [
          3,
          "5"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Test and Optimize Terrain Visualization Performance on Android and iOS",
        "description": "Evaluate and enhance terrain visualization performance across a range of Android and iOS devices, implementing performance tuning settings and timer configurations for optimal frame rates.",
        "details": "Begin by profiling terrain visualization performance on representative Android and iOS devices, measuring frame rates, memory usage, and rendering latency under various scene complexities. Adjust key Unity Quality Settings such as LOD Bias, V Sync Count, Shadow Distance, Shadow Resolution, and Anti-Aliasing (preferably disabling it or using FXAA for mobile) to find the optimal balance between visual fidelity and performance. Implement dynamic adaptive multi-resolution modeling (e.g., quad-tree based LOD) to reduce draw calls and terrain data size, leveraging GPU acceleration where possible but accounting for mobile hardware limitations. Integrate configurable performance tuning options (e.g., sliders for LOD, toggles for shadows) into the app settings. Configure timer intervals for real-time data overlays and camera updates to maintain smooth interaction without overloading the device. Document all optimizations and provide fallback settings for lower-end devices.",
        "testStrategy": "1. Deploy the app to a variety of Android and iOS devices, including both high-end and low-end models. 2. Use profiling tools (e.g., Unity Profiler, Xcode Instruments, Android Studio Profiler) to measure FPS, memory usage, and CPU/GPU load during typical terrain visualization scenarios. 3. Verify that performance tuning settings are accessible and effective, allowing users to adjust quality for smoother experience. 4. Confirm that timer configurations maintain responsive updates (e.g., camera, overlays) without causing frame drops. 5. Ensure that visual quality remains acceptable at all performance levels and that the app does not crash or exhibit rendering artifacts. 6. Document results and iterate on settings as needed to achieve target performance benchmarks (e.g., 30+ FPS on low-end devices, 60 FPS on high-end devices).",
        "status": "pending",
        "dependencies": [
          3,
          6,
          "7"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Document Terrain Visualization Functionality in Naxalibre",
        "description": "Create comprehensive documentation for the terrain visualization features in Naxalibre, covering usage, native code setup, and performance optimization.",
        "details": "Develop detailed documentation that explains how to use the terrain visualization functionality in Naxalibre. Include step-by-step usage instructions with code examples for both JavaScript and native implementations, referencing how to visualize elevation from DEM (RGBA tiles), configure data sources, and overlay tracks, labels, and points. Provide a section on setting up and integrating native code, including any platform-specific requirements or dependencies. Add a dedicated section on performance optimization, covering best practices for handling large datasets, efficient rendering, and memory management. Where relevant, link to or summarize related tutorials and external resources (such as MapLibre and MapTiler examples) to illustrate advanced usage and troubleshooting. Ensure the documentation is clear, well-structured, and accessible to both new and experienced developers.",
        "testStrategy": "Review the documentation for completeness and clarity by having a developer follow the instructions to set up and use terrain visualization in a fresh Naxalibre project. Verify that all code examples work as described and that native code setup steps result in a successful build and execution. Test performance optimization tips by benchmarking rendering speed and memory usage before and after applying recommendations. Solicit feedback from at least one developer unfamiliar with the feature to ensure usability.",
        "status": "pending",
        "dependencies": [
          3,
          7,
          "8"
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "tags": {
        "master": {
          "description": "Main task list for terrain visualization integration"
        }
      },
      "created": "2025-06-23T19:59:46.092Z",
      "description": "Tasks for master context",
      "updated": "2025-06-23T20:03:27.487Z"
    }
  }
}